// Code generated by schema-generate. DO NOT EDIT.

package schema

import (
    "bytes"
    "encoding/json"
    "errors"
)

// Root
type Root *FileFormatFile

// CloseFrameEvent 
type CloseFrameEvent struct {
  At float64 `json:"at"`
  Frame float64 `json:"frame"`
  Type string `json:"type"`
}

// FileFormatEventedProfile 
type FileFormatEventedProfile struct {
  EndValue float64 `json:"endValue"`
  Events []interface{} `json:"events"`
  Name string `json:"name"`
  StartValue float64 `json:"startValue"`
  Type string `json:"type"`
  Unit string `json:"unit"`
}

// FileFormatFile 
type FileFormatFile struct {
  ActiveProfileIndex float64 `json:"activeProfileIndex,omitempty"`
  Exporter string `json:"exporter,omitempty"`
  Name string `json:"name,omitempty"`
  Profiles []interface{} `json:"profiles"`
  Schema string `json:"$schema"`
  Shared *Shared `json:"shared"`
}

// FileFormatFrame 
type FileFormatFrame struct {
  Col float64 `json:"col,omitempty"`
  File string `json:"file,omitempty"`
  Line float64 `json:"line,omitempty"`
  Name string `json:"name"`
}

// FileFormatIProfile 
type FileFormatIProfile struct {
  Type string `json:"type"`
}

// FileFormatSampledProfile 
type FileFormatSampledProfile struct {
  EndValue float64 `json:"endValue"`
  Name string `json:"name"`
  Samples [][]float64 `json:"samples"`
  StartValue float64 `json:"startValue"`
  Type string `json:"type"`
  Unit string `json:"unit"`
  Weights []float64 `json:"weights"`
}

// IEvent 
type IEvent struct {
  At float64 `json:"at"`
  Type string `json:"type"`
}

// OpenFrameEvent 
type OpenFrameEvent struct {
  At float64 `json:"at"`
  Frame float64 `json:"frame"`
  Type string `json:"type"`
}

// Shared 
type Shared struct {
  Frames []*FileFormatFrame `json:"frames"`
}

func (strct *CloseFrameEvent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "At" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "at" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"at\": ")
	if tmp, err := json.Marshal(strct.At); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Frame" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "frame" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"frame\": ")
	if tmp, err := json.Marshal(strct.Frame); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CloseFrameEvent) UnmarshalJSON(b []byte) error {
    atReceived := false
    frameReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "at":
            if err := json.Unmarshal([]byte(v), &strct.At); err != nil {
                return err
             }
            atReceived = true
        case "frame":
            if err := json.Unmarshal([]byte(v), &strct.Frame); err != nil {
                return err
             }
            frameReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if at (a required property) was received
    if !atReceived {
        return errors.New("\"at\" is required but was not present")
    }
    // check if frame (a required property) was received
    if !frameReceived {
        return errors.New("\"frame\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *FileFormatEventedProfile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EndValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "endValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"endValue\": ")
	if tmp, err := json.Marshal(strct.EndValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Events" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "events" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StartValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "startValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startValue\": ")
	if tmp, err := json.Marshal(strct.StartValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Unit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileFormatEventedProfile) UnmarshalJSON(b []byte) error {
    endValueReceived := false
    eventsReceived := false
    nameReceived := false
    startValueReceived := false
    typeReceived := false
    unitReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "endValue":
            if err := json.Unmarshal([]byte(v), &strct.EndValue); err != nil {
                return err
             }
            endValueReceived = true
        case "events":
            if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
                return err
             }
            eventsReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "startValue":
            if err := json.Unmarshal([]byte(v), &strct.StartValue); err != nil {
                return err
             }
            startValueReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "unit":
            if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
                return err
             }
            unitReceived = true
        }
    }
    // check if endValue (a required property) was received
    if !endValueReceived {
        return errors.New("\"endValue\" is required but was not present")
    }
    // check if events (a required property) was received
    if !eventsReceived {
        return errors.New("\"events\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if startValue (a required property) was received
    if !startValueReceived {
        return errors.New("\"startValue\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    // check if unit (a required property) was received
    if !unitReceived {
        return errors.New("\"unit\" is required but was not present")
    }
    return nil
}

func (strct *FileFormatFile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "activeProfileIndex" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"activeProfileIndex\": ")
	if tmp, err := json.Marshal(strct.ActiveProfileIndex); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exporter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exporter\": ")
	if tmp, err := json.Marshal(strct.Exporter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Profiles" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "profiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"profiles\": ")
	if tmp, err := json.Marshal(strct.Profiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Schema" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "$schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"$schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Shared" field is required
    if strct.Shared == nil {
        return nil, errors.New("shared is a required field")
    }
    // Marshal the "shared" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"shared\": ")
	if tmp, err := json.Marshal(strct.Shared); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileFormatFile) UnmarshalJSON(b []byte) error {
    profilesReceived := false
    schemaReceived := false
    sharedReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "activeProfileIndex":
            if err := json.Unmarshal([]byte(v), &strct.ActiveProfileIndex); err != nil {
                return err
             }
        case "exporter":
            if err := json.Unmarshal([]byte(v), &strct.Exporter); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "profiles":
            if err := json.Unmarshal([]byte(v), &strct.Profiles); err != nil {
                return err
             }
            profilesReceived = true
        case "$schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
            schemaReceived = true
        case "shared":
            if err := json.Unmarshal([]byte(v), &strct.Shared); err != nil {
                return err
             }
            sharedReceived = true
        }
    }
    // check if profiles (a required property) was received
    if !profilesReceived {
        return errors.New("\"profiles\" is required but was not present")
    }
    // check if $schema (a required property) was received
    if !schemaReceived {
        return errors.New("\"$schema\" is required but was not present")
    }
    // check if shared (a required property) was received
    if !sharedReceived {
        return errors.New("\"shared\" is required but was not present")
    }
    return nil
}

func (strct *FileFormatFrame) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "col" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"col\": ")
	if tmp, err := json.Marshal(strct.Col); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "file" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"file\": ")
	if tmp, err := json.Marshal(strct.File); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "line" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"line\": ")
	if tmp, err := json.Marshal(strct.Line); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileFormatFrame) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "col":
            if err := json.Unmarshal([]byte(v), &strct.Col); err != nil {
                return err
             }
        case "file":
            if err := json.Unmarshal([]byte(v), &strct.File); err != nil {
                return err
             }
        case "line":
            if err := json.Unmarshal([]byte(v), &strct.Line); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *FileFormatIProfile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileFormatIProfile) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *FileFormatSampledProfile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EndValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "endValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"endValue\": ")
	if tmp, err := json.Marshal(strct.EndValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Samples" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "samples" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"samples\": ")
	if tmp, err := json.Marshal(strct.Samples); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StartValue" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "startValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startValue\": ")
	if tmp, err := json.Marshal(strct.StartValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Unit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Weights" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "weights" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"weights\": ")
	if tmp, err := json.Marshal(strct.Weights); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileFormatSampledProfile) UnmarshalJSON(b []byte) error {
    endValueReceived := false
    nameReceived := false
    samplesReceived := false
    startValueReceived := false
    typeReceived := false
    unitReceived := false
    weightsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "endValue":
            if err := json.Unmarshal([]byte(v), &strct.EndValue); err != nil {
                return err
             }
            endValueReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "samples":
            if err := json.Unmarshal([]byte(v), &strct.Samples); err != nil {
                return err
             }
            samplesReceived = true
        case "startValue":
            if err := json.Unmarshal([]byte(v), &strct.StartValue); err != nil {
                return err
             }
            startValueReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "unit":
            if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
                return err
             }
            unitReceived = true
        case "weights":
            if err := json.Unmarshal([]byte(v), &strct.Weights); err != nil {
                return err
             }
            weightsReceived = true
        }
    }
    // check if endValue (a required property) was received
    if !endValueReceived {
        return errors.New("\"endValue\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if samples (a required property) was received
    if !samplesReceived {
        return errors.New("\"samples\" is required but was not present")
    }
    // check if startValue (a required property) was received
    if !startValueReceived {
        return errors.New("\"startValue\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    // check if unit (a required property) was received
    if !unitReceived {
        return errors.New("\"unit\" is required but was not present")
    }
    // check if weights (a required property) was received
    if !weightsReceived {
        return errors.New("\"weights\" is required but was not present")
    }
    return nil
}

func (strct *IEvent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "At" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "at" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"at\": ")
	if tmp, err := json.Marshal(strct.At); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *IEvent) UnmarshalJSON(b []byte) error {
    atReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "at":
            if err := json.Unmarshal([]byte(v), &strct.At); err != nil {
                return err
             }
            atReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if at (a required property) was received
    if !atReceived {
        return errors.New("\"at\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *OpenFrameEvent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "At" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "at" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"at\": ")
	if tmp, err := json.Marshal(strct.At); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Frame" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "frame" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"frame\": ")
	if tmp, err := json.Marshal(strct.Frame); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OpenFrameEvent) UnmarshalJSON(b []byte) error {
    atReceived := false
    frameReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "at":
            if err := json.Unmarshal([]byte(v), &strct.At); err != nil {
                return err
             }
            atReceived = true
        case "frame":
            if err := json.Unmarshal([]byte(v), &strct.Frame); err != nil {
                return err
             }
            frameReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if at (a required property) was received
    if !atReceived {
        return errors.New("\"at\" is required but was not present")
    }
    // check if frame (a required property) was received
    if !frameReceived {
        return errors.New("\"frame\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Shared) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Frames" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "frames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"frames\": ")
	if tmp, err := json.Marshal(strct.Frames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Shared) UnmarshalJSON(b []byte) error {
    framesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "frames":
            if err := json.Unmarshal([]byte(v), &strct.Frames); err != nil {
                return err
             }
            framesReceived = true
        }
    }
    // check if frames (a required property) was received
    if !framesReceived {
        return errors.New("\"frames\" is required but was not present")
    }
    return nil
}
